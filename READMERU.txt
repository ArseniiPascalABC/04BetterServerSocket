Описание
На этом этапе вы напишете программу, которая отправляет на сервер настоящие текстовые файлы и файлы изображений.
Сервер хранит файлы и отправляет их обратно по запросу, пока вы не решите их удалить. Также сервер должен уметь распознавать
каждый файл по его уникальному идентификатору.

Если файл создан успешно, сервер должен выдать целочисленный идентификатор
после кода 200 и одного пробела. Если создать файл не удалось, идентификатор не требуется. С этого момента вы сможете получить
доступ к файлу на сервере, используя либо его идентификатор, либо имя файла. Для этого после команды GET или DELETE вы должны
указать, хотите ли вы использовать идентификатор файла или имя. Давайте использовать BY_ID и BY_NAME в качестве ключевых слов.
Каждый раз, когда вы хотите получить файл с сервера, вы можете написать либо GET BY_ID 12, либо GET BY_NAME filename.txt.
То же самое относится к DELETE BY_ID и DELETE BY_NAME. Обратите внимание, что вам не нужны эти ключевые слова с методом PUT:
он просто сохраняет новый файл на сервере, и сервер отправляет вам новый идентификатор файла.


Конечно, большинство файлов обычно намного больше, чем одна строка текста. Процесс сохранения больших файлов может занять
некоторое время, поэтому следует использовать параллельный подход. Например, вы можете захотеть использовать исполнители,
и каждый раз, когда клиент отправляет запрос, вы должны выполнять запрошенную задачу в пуле потоков, а не в основном потоке.
Основной поток должен просто ждать другого запроса. Обратите внимание, что сопоставление идентификаторов с именами файлов
следует использовать синхронно, поскольку к нему имеют доступ разные потоки. Не забудьте сохранить где-нибудь эту карту,
чтобы не потерять ее при перезагрузке сервера. После перезагрузки сервера проверьте, не запускается ли сразу процесс генерации ID.
Обратите внимание, что вы не можете отправлять байты через текстовый поток: хотя для байтов требуется однобайтовый поток,
текстовый поток является переменным байтом (это связано с тем, что строки в Java кодируются в формате UTF, когда они отправляются
с использованием DataInputStream). Решение заключается в отправке самого массива байтов, а не байтов, закодированных как текст.
Когда вы получаете массив байтов, вы не можете точно сказать, где находится конец потока, в отличие от случая с методом readUTF,
когда вы читаете только одну строку за раз. Эту проблему можно решить, добавив количество байтов в самом начале потока.
Отправитель вычисляет и отправляет это число, за которым следует поток байтов, а получатель считывает число, а затем считывает
поток с указанным количеством байтов. Вы можете использовать следующий фрагмент из переполнения стека, чтобы понять, как это
работает:
byte[] message = ... Socket socket = ... DataOutputStream output = ...

/* after writing some other data */

output.writeInt(message.length); // write length of the message output.write(message); // write the message

Socket socket = ... DataInputStream input = ...

/* after reading some other data */

int length = input.readInt(); // read length of incoming message byte[] message = new byte[length]; input.readFully(message, 0, message.length); // read the message
На этом этапе вы должны написать клиентскую программу, которая побуждает пользователя к действию. Если они хотят сохранить файл на сервере, программа должна
спросить пользователя, какой файл из папки ../client/data нужно сохранить. После этого пользователь должен указать имя файла
(имя не должно содержать пробелов и табуляций). Если пользователь не хочет указывать имя, он должен просто нажать Enter, ничего не вводя.
Сервер должен сгенерировать уникальное имя для этого файла и отправить обратно идентификатор. Файл должен быть сохранен в папке .../server/data/.
Создайте собственную реализацию этого поведения.
Если пользователь хочет получить файл, клиентская программа должна спросить, хочет ли пользователь использовать идентификатор или имя файла.
После ввода id или имени пользователь должен указать имя, под которым должен быть сохранен файл. Файл должен быть сохранен в папке .../client/data/.
Если пользователь хочет удалить файл, клиентская программа должна спросить, хочет ли пользователь использовать идентификатор или имя файла.
После ввода идентификатора или имени программа должна отправить запрос на сервер.
Поскольку сервер не может отключиться сам по себе, а тесты требуют остановки программы в определенный момент, следует реализовать простой способ остановки сервера.
Клиент должен иметь возможность обрабатывать действие выхода и отправлять соответствующее сообщение на сервер. Когда клиент отправляет выход, вы должны остановить
сервер. Примечание: вы не должны допускать такого поведения в обычной ситуации, когда нет необходимости проводить тестирование. Цели на этом этапе ваша
клиентская программа должна:
Печать Сервер запущен! сообщение при запуске программы.
Получите запрос от клиента и ответьте соответствующим образом.
Отправить ответ в зависимости от типа запроса:
Для запроса PUT отправьте код состояния 200 и уникальный INTEGER IDENTIFIER, разделенные одним пробелом, если файл создан успешно; в противном случае отправьте код состояния 403.
Для запроса GET отправьте код состояния 200 и FILE_CONTENT, разделенные одним пробелом, если файл существует; в противном случае отправьте код состояния 404.
Для запроса DELETE отправьте код состояния 200, если файл успешно удален; в противном случае отправьте код состояния 404.
Серверная программа не должна завершаться, пока не получит команду выхода. Примеры
Символ «больше чем», за которым следует пробел (>), представляет ввод пользователя. Обратите внимание, что это не часть ввода.

Пример 1

Введите действие (1 - получить файл, 2 - сохранить файл, 3 - удалить файл): > 2 Введите имя файла: > my_cat.jpg Введите имя файла, который необходимо сохранить на сервере: > Запрос отправлен . Ответ говорит, что файл сохранен! ID = 23

Пример 2

Введите действие (1 - получить файл, 2 - сохранить файл, 3 - удалить файл): > 1 Вы хотите получить файл по имени или по id (1 - имя, 2 - id): > 2 Ввести id : > 23 Запрос отправлен. Файл был скачан! Укажите для него имя: > cat.jpg Файл сохранен на жестком диске!

Пример 3

Введите действие (1 - получить файл, 2 - сохранить файл, 3 - удалить файл): > 3 Вы хотите удалить файл по имени или по id (1 - имя, 2 - id): > 2 Введите id : > 23 Запрос отправлен. В ответе говорится, что этот файл был успешно удален!

Пример 4

Введите действие (1 - получить файл, 2 - сохранить файл, 3 - удалить файл): > 3 Вы хотите удалить файл по имени или по id (1 - имя, 2 - id): > 2 Введите id : > 23 Запрос отправлен. В ответе написано, что этот файл не найден!

Пример 5

Введите действие (1 - получить файл, 2 - сохранить файл, 3 - удалить файл): > выйти Запрос отправлен.